#include <gtest/gtest.h>
#ifndef UNIT_TESTS
#define UNIT_TESTS
#endif
#include "Kuznechik.hpp"
#include "OMAC.hpp"

static const Kuznechik сipher({
    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
});

TEST(OMACTest, TestKeysInit) {
    OMAC ctx(сipher);
    static const SecureBuffer expected_key1 = {
        0x29, 0x7d, 0x82, 0xbc, 0x4d, 0x39, 0xe3, 0xca,
        0x0d, 0xe0, 0x57, 0x32, 0x98, 0x15, 0x1d, 0xc7
    };
    static const SecureBuffer expected_key2 = {
        0x52, 0xfb, 0x05, 0x78, 0x9a, 0x73, 0xc7, 0x94,
        0x1b, 0xc0, 0xae, 0x65, 0x30, 0x2a, 0x3b, 0x8e 
    };
    EXPECT_EQ(ctx.getKey1(), expected_key1);
    EXPECT_EQ(ctx.getKey2(), expected_key2);
}

TEST(OMACTest, TestFullBlocks) {
    OMAC ctx(сipher);
    static const std::vector<uint8_t> plain_text[] = {
        std::vector<uint8_t>{
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,
            0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88
        },
        std::vector<uint8_t>{
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a
        },
        std::vector<uint8_t>{
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00
        },
        std::vector<uint8_t>{
            0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
            0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11
        }
    };
    static const SecureBuffer<16> states[] = {
        {
            0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30,
            0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd
        },
        {
            0x1a, 0xc9, 0xd9, 0x76, 0xf8, 0x36, 0x36, 0xf5,
            0x5a, 0xe9, 0xef, 0x30, 0x5e, 0x7c, 0x90, 0xd2
        },
        {
            0x15, 0x64, 0x5a, 0xf4, 0xa7, 0x8e, 0x50, 0xa9,
            0xab, 0xe8, 0xdb, 0x4b, 0x75, 0x4d, 0xe3, 0xf2
        },
        {
            0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3,
            0x4d, 0xde, 0xb3, 0x5b, 0x37, 0x74, 0x9c, 0x67
        }
    };
    static const std::vector<uint8_t> expected_mac{0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3};
    ctx.update(plain_text[0]);
    ctx.update(plain_text[1]);
    EXPECT_EQ(ctx.getAccumulator(), states[0]);
    ctx.update(plain_text[2]);
    EXPECT_EQ(ctx.getAccumulator(), states[1]);
    ctx.update(plain_text[3]);
    EXPECT_EQ(ctx.getAccumulator(), states[2]);
    const std::vector<uint8_t> mac = ctx.digest(8);
    EXPECT_EQ(ctx.getAccumulator(), states[3]);
    EXPECT_EQ(mac, expected_mac);
}

TEST(OMACTest, TestBufferDigest) {
    OMAC ctx(сipher);
    static const std::vector<uint8_t> plain_text = {
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,
            0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
            0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
            0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11
    };
    static const std::vector<uint8_t> expected_mac{
        0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3,
        0x4d, 0xde, 0xb3, 0x5b, 0x37, 0x74, 0x9c, 0x67
    };
    ctx.update(plain_text);
    std::vector<uint8_t> mac(16);
    ctx.digest(mac.data());
    EXPECT_EQ(mac, expected_mac);
}

TEST(OMACTest, TestPartial) {
    OMAC ctx(сipher);
    static const std::vector<uint8_t> plain_text[] = {
        std::vector<uint8_t>{0x11},
        std::vector<uint8_t>{0x22, 0x33},
        std::vector<uint8_t>{0x44, 0x55, 0x66},
        std::vector<uint8_t>{0x77, 0x00, 0xff, 0xee, 0xdd},
        std::vector<uint8_t>{0xcc, 0xbb, 0xaa},
        std::vector<uint8_t>{0x99, 0x88, 0x00, 0x11, 0x22}, // переполнит буфер на 3 байта
        std::vector<uint8_t>{
            0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
            0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x11, 0x22, 0x33,
            0x44, 0x55, 0x66, 0x77, 0x88,
        }, // переполнит буфер на 8 байт.
        std::vector<uint8_t>{
            0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00
        }, // дополнит до полного
        std::vector<uint8_t>{
            0x22, 0x33, 0x44, 0x55,
        } // в конце будет неполное заполенение.
    };
    static const SecureBuffer<16> states[] = {
        {
            0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30,
            0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd
        },
        {
            0x1a, 0xc9, 0xd9, 0x76, 0xf8, 0x36, 0x36, 0xf5,
            0x5a, 0xe9, 0xef, 0x30, 0x5e, 0x7c, 0x90, 0xd2
        },
        {
            0x15, 0x64, 0x5a, 0xf4, 0xa7, 0x8e, 0x50, 0xa9,
            0xab, 0xe8, 0xdb, 0x4b, 0x75, 0x4d, 0xe3, 0xf2
        },
        {
            0xD8, 0x49, 0xDD, 0x35, 0x2F, 0xAA, 0x57, 0xB1,
            0x29, 0xD8, 0x01, 0x7B, 0xA1, 0x10, 0x8F, 0x5A
        }
    };
    static const std::vector<uint8_t> expected_mac{0xD8, 0x49, 0xDD, 0x35, 0x2F, 0xAA, 0x57, 0xB1};
    for (uint8_t i = 0; i < 6; ++i)
        ctx.update(plain_text[i]);
    EXPECT_EQ(ctx.getAccumulator(), states[0]);
    ctx.update(plain_text[6]);
    EXPECT_EQ(ctx.getAccumulator(), states[1]);
    ctx.update(plain_text[7]);
    ctx.update(plain_text[8]);
    EXPECT_EQ(ctx.getAccumulator(), states[2]);
    const std::vector<uint8_t> mac = ctx.digest(8);
    EXPECT_EQ(ctx.getAccumulator(), states[3]);
    EXPECT_EQ(mac, expected_mac);
}

TEST(OMACTest, TestZeroUpdate) {
    OMAC ctx(сipher);
    static const std::vector<uint8_t> plain_text[] = {
        std::vector<uint8_t>{
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,
            0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88
        },
        std::vector<uint8_t>{
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a
        },
        std::vector<uint8_t>{}, // не должен влиять
        std::vector<uint8_t>{
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00
        },
        std::vector<uint8_t>{
            0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
            0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11
        }
    };
    static const SecureBuffer<16> states[] = {
        {
            0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30,
            0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd
        },
        {
            0x1a, 0xc9, 0xd9, 0x76, 0xf8, 0x36, 0x36, 0xf5,
            0x5a, 0xe9, 0xef, 0x30, 0x5e, 0x7c, 0x90, 0xd2
        },
        {
            0x15, 0x64, 0x5a, 0xf4, 0xa7, 0x8e, 0x50, 0xa9,
            0xab, 0xe8, 0xdb, 0x4b, 0x75, 0x4d, 0xe3, 0xf2
        },
        {
            0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3,
            0x4d, 0xde, 0xb3, 0x5b, 0x37, 0x74, 0x9c, 0x67
        }
    };
    static const std::vector<uint8_t> expected_mac{0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3};
    ctx.update(plain_text[0]);
    ctx.update(plain_text[1]);
    EXPECT_EQ(ctx.getAccumulator(), states[0]);
    ctx.update(plain_text[2]);
    ctx.update(plain_text[3]);
    EXPECT_EQ(ctx.getAccumulator(), states[1]);
    ctx.update(plain_text[4]);
    EXPECT_EQ(ctx.getAccumulator(), states[2]);
    const std::vector<uint8_t> mac = ctx.digest(8);
    EXPECT_EQ(ctx.getAccumulator(), states[3]);
    EXPECT_EQ(mac, expected_mac);
}

TEST(OMACTest, TestDigestThrow) {
    OMAC ctx(сipher);
    EXPECT_THROW(ctx.digest(17), std::invalid_argument);
}

TEST(OMACTest, TestClear) {
    static const std::vector<uint8_t> plain_text = {
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,
            0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
            0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
            0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
            0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11
    };
    static const std::vector<uint8_t> expected_mac{0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3};
    OMAC ctx(сipher);
    ctx.update(plain_text);
    const std::vector<uint8_t> mac1 = ctx.digest(8);
    EXPECT_EQ(mac1, expected_mac);
    ctx.clear();
    ctx.update(plain_text);
    const std::vector<uint8_t> mac2 = ctx.digest(8);
    EXPECT_EQ(mac2, expected_mac);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}