#include <gtest/gtest.h>
#include <iomanip>
#include "NMAC256.hpp"
#include "OpenSSLNMAC256.hpp"

INITIALIZE_EASYLOGGINGPP

template <size_t N>
void PrintTo(const SecureBuffer<N> &buf, std::ostream* os) {
    *os << std::hex << std::uppercase << std::setfill('0');
    for (uint8_t byte : buf)
        *os << std::setw(2) << static_cast<int>(byte);
}

std::string ToHex(const std::vector<uint8_t>& data) {
    std::ostringstream oss;
    oss << std::hex << std::uppercase << std::setfill('0');
    for (uint8_t b : data)
        oss << std::setw(2) << static_cast<int>(b);
    return oss.str();
}

TEST(NMAC256Test, TestSmallKey) {
    static const std::vector<uint8_t> text = {
        0x01, 0x26, 0xbd, 0xb8, 0x78, 0x00, 0xaf, 0x21,
        0x43, 0x41, 0x45, 0x65, 0x63, 0x78, 0x01, 0x00
    };
    static const SecureBuffer key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    NMAC256 macer(key);
    macer.update(text);
    std::vector<uint8_t> mac = macer.digest();
    OpenSSLNMAC256 OpenSSLmacer(key);
    OpenSSLmacer.update(text);
    std::vector<uint8_t> expected_mac = OpenSSLmacer.digest();
    EXPECT_TRUE(mac == expected_mac)
        << "mac: " << ToHex(mac) << "\n"
        << "Ожидаемый mac: " << ToHex(expected_mac);
}

TEST(NMAC256Test, TestBigKey) {
    static const std::vector<uint8_t> text = {
        0x01, 0x26, 0xbd, 0xb8, 0x78, 0x00, 0xaf, 0x21,
        0x43, 0x41, 0x45, 0x65, 0x63, 0x78, 0x01, 0x00
    };
    static const SecureBuffer key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    NMAC256 macer(key);
    macer.update(text);
    std::vector<uint8_t> mac = macer.digest();
    OpenSSLNMAC256 OpenSSLmacer(key);
    OpenSSLmacer.update(text);
    std::vector<uint8_t> expected_mac = OpenSSLmacer.digest();
    EXPECT_TRUE(mac == expected_mac)
        << "mac: " << ToHex(mac) << "\n"
        << "Ожидаемый mac: " << ToHex(expected_mac);
}

TEST(NMAC256Test, TestHMACClear) {
    static const std::vector<uint8_t> text = {
        0x01, 0x26, 0xbd, 0xb8, 0x78, 0x00, 0xaf, 0x21,
        0x43, 0x41, 0x45, 0x65, 0x63, 0x78, 0x01, 0x00
    };
    static const SecureBuffer key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    NMAC256 macer(key);
    OpenSSLNMAC256 OpenSSLmacer(key);
    for (uint8_t i = 0; i < 2; ++i) {
        macer.update(text);
        std::vector<uint8_t> mac = macer.digest();
        OpenSSLmacer.update(text);
        std::vector<uint8_t> expected_mac = OpenSSLmacer.digest();
        EXPECT_TRUE(mac == expected_mac)
            << "mac: " << ToHex(mac) << "\n"
            << "Ожидаемый mac: " << ToHex(expected_mac);
        macer.clear();
        OpenSSLmacer.clear();
    }
}

TEST(NMAC256Test, TestHMACRaw) {
    static const uint8_t text[] = {
        0x01, 0x26, 0xbd, 0xb8, 0x78, 0x00, 0xaf, 0x21,
        0x43, 0x41, 0x45, 0x65, 0x63, 0x78, 0x01, 0x00
    };
    static const SecureBuffer key = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    NMAC256 macer(key);
    macer.update(text, 16);
    std::vector<uint8_t> mac(32);
    macer.digest(mac.data());
    OpenSSLNMAC256 OpenSSLmacer(key);
    OpenSSLmacer.update(text, 16);
    std::vector<uint8_t> expected_mac(32);
    OpenSSLmacer.digest(expected_mac.data());
    EXPECT_TRUE(mac == expected_mac)
        << "mac: " << ToHex(mac) << "\n"
        << "Ожидаемый mac: " << ToHex(expected_mac);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}